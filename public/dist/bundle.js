/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _walker_scene_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./walker/scene.js */ \"./walker/scene.js\");\n\nconst scene = new _walker_scene_js__WEBPACK_IMPORTED_MODULE_0__.Scene();\nawait scene.load();\nscene.start();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://walker/./index.js?");

/***/ }),

/***/ "./walker/constants.js":
/*!*****************************!*\
  !*** ./walker/constants.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIR_DAMP: () => (/* binding */ AIR_DAMP),\n/* harmony export */   DEBUG: () => (/* binding */ DEBUG),\n/* harmony export */   EDIT_MODE: () => (/* binding */ EDIT_MODE),\n/* harmony export */   FULL_CIRCLE: () => (/* binding */ FULL_CIRCLE),\n/* harmony export */   LEVEL_LAYER_MAX: () => (/* binding */ LEVEL_LAYER_MAX),\n/* harmony export */   LEVEL_LAYER_MIDDLE: () => (/* binding */ LEVEL_LAYER_MIDDLE),\n/* harmony export */   PATH_TRAVERSE_ACCURATE: () => (/* binding */ PATH_TRAVERSE_ACCURATE)\n/* harmony export */ });\n/* CONSTANTS */\nconst FULL_CIRCLE = 2 * Math.PI;\n\nconst LEVEL_LAYER_MAX = 7;\n\nconst LEVEL_LAYER_MIDDLE = 3;\n\n/* CONTROL */\nconst DEBUG = false;\n\nconst EDIT_MODE = false;\n\nconst PATH_TRAVERSE_ACCURATE = true;\n\n\n/* PHYSICS */\nconst AIR_DAMP = 0.92;\n\n\n\n//# sourceURL=webpack://walker/./walker/constants.js?");

/***/ }),

/***/ "./walker/level.js":
/*!*************************!*\
  !*** ./walker/level.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Level: () => (/* binding */ Level)\n/* harmony export */ });\n/* harmony import */ var _traveller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./traveller.js */ \"./walker/traveller.js\");\n/* harmony import */ var _tower_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tower.js */ \"./walker/tower.js\");\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ \"./walker/path.js\");\n/* harmony import */ var _resource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource.js */ \"./walker/resource.js\");\n/* harmony import */ var _objects_towers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./objects/towers.js */ \"./walker/objects/towers.js\");\n/* harmony import */ var _objects_travellers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./objects/travellers.js */ \"./walker/objects/travellers.js\");\n\n\n\n\n\n\n\nclass Level {\n    constructor(state) {\n        this.state = state;\n        this.loadPercent = 0;\n        this.resources = {\n            levels: [],\n            sprites: [],\n        };\n\n        this.resourceCount = 0;\n        this.resourceLoadedCount = 0;\n        this.ready = true;\n\n        return this;\n    }\n\n    async unloadResources() {\n        this.resources = {\n            levels: [],\n            sprites: [],\n        };\n\n        this.resourceCount = 0;\n        this.resourceLoadedCount = 0;\n    }\n\n    async loadResources(resources) {\n        let resourceFails = [];\n\n        const loadPromises = [];\n        resources.forEach(async r => {\n            loadPromises.push(\n                r.load()\n                    .then(() => {\n                        this.resourceLoadedCount++;\n                    })\n                    .catch(error => {\n                        console.log(error);\n                        resourceFails.push(r);\n                    })\n            );\n        });\n\n        await Promise.all(loadPromises);\n        \n        if (resourceFails.length > 0) {\n            console.log(`[Resource] failed to load ${resourceFails.length} resources`);\n            // console.log(this.resourceFails);\n\n            throw new Error('failed to load resources');\n        }\n\n        console.log(`[Resource] loaded ${this.resourceLoadedCount} resources`);\n        this.resourceCount += this.resourceLoadedCount;\n    }\n\n    async loadLevel(id) {\n        if (!this.ready) {\n            throw new Error('global resources not ready');\n        }\n\n        let levelResource = this.resources.levels[id];\n\n        if (levelResource === undefined) {\n            levelResource = new _resource_js__WEBPACK_IMPORTED_MODULE_3__.LevelResource(id);\n            await this.loadResources([levelResource]);\n        }\n\n        this.state.addLayerResource(levelResource);\n        levelResource.paths.forEach(path => {\n            console.log('[Level] adding path:', path);\n            this.state.addPath(path);\n        });\n    }\n\n    loadTowers(file) {\n        // return [tower, ...];\n    }\n\n    loadEnemies(file) {\n        // return [enemy, ...];\n    }\n\n    loadProjectiles(file) {\n        // return [projectile, ...];\n    }\n\n    loadUpgrades(file) {\n        // return [upgrade, ...];\n    }\n\n    loadWaves(file) {\n        // return [wave, ...];\n    }\n     \n    injectTestLevel() {\n        const state = this.state;\n        // const path = new Path();\n        // path.parts.push(new PathPartLine(100, 100, 200, 200));\n        // path.parts.push(new PathPartLine(200, 200, 300, 100));\n        // path.parts.push(new PathPartBezier(300, 100, 400, 200, 500, 100, 600, 200));\n        // path.parts.push(new PathPartBezier(600, 200, 700, 300, 700, 600, 400, 600));\n        // path.parts.push(new PathPartBezier(400, 600, 200, 600, 200, 0, 550, 50));\n        // this.state.addPath(path);\n        \n        // const tower1 = new Tower(state, 200, 100, towers.TOWER_BASIC);\n        // tower1.addUpgrade(towers.TOWER_BASIC.upgrades.PiercingShot);\n        // tower1.targettingMode = 'strongest';\n        // state.addTower(tower1);\n        \n        const tower2 = new _tower_js__WEBPACK_IMPORTED_MODULE_1__.Tower(state, 490, 350, _objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC);\n        tower2.targettingMode = 'first';\n        tower2.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.FasterFiring);\n        tower2.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.PiercingShot);\n        tower2.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.PiercingShot2);\n        tower2.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.IncreasedRange);\n        state.addTower(tower2);\n        \n        const tower3 = new _tower_js__WEBPACK_IMPORTED_MODULE_1__.Tower(state, 290, 170, _objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_SPRAY);\n        state.addTower(tower3);\n        \n        const tower4 = new _tower_js__WEBPACK_IMPORTED_MODULE_1__.Tower(state, 90, 290, _objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC);\n        tower4.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.FasterFiring);\n        tower4.addUpgrade(_objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_BASIC.upgrades.PiercingShot);\n        state.addTower(tower4);\n\n        const gat = new _tower_js__WEBPACK_IMPORTED_MODULE_1__.Tower(state, 750, 250, _objects_towers_js__WEBPACK_IMPORTED_MODULE_4__.TOWER_GAT);\n        state.addTower(gat);\n\n        return this;\n    }\n\n    createTestSpawn() {\n        this.createTestSpawnInterval(100, _objects_travellers_js__WEBPACK_IMPORTED_MODULE_5__.BLOON_BLUE);\n        this.createTestSpawnInterval(200, _objects_travellers_js__WEBPACK_IMPORTED_MODULE_5__.BLOON_PINK);\n        this.createTestSpawnInterval(420, _objects_travellers_js__WEBPACK_IMPORTED_MODULE_5__.BLOON_BLACK);\n        this.createTestSpawnInterval(450, _objects_travellers_js__WEBPACK_IMPORTED_MODULE_5__.BLOON_WHITE);\n\n        return this;\n    }\n    \n    createTestSpawnInterval(interval, type) {\n        const { x, y } = this.state.paths[0].parts[0].getOrigin();\n        setInterval(() => {\n            const traveller = new _traveller_js__WEBPACK_IMPORTED_MODULE_0__.Traveller(x, y, this.state.paths[0], type);\n            this.state.addTraveller(traveller);\n        }, interval);\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/level.js?");

/***/ }),

/***/ "./walker/objects/towers.js":
/*!**********************************!*\
  !*** ./walker/objects/towers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TOWER_BASIC: () => (/* binding */ TOWER_BASIC),\n/* harmony export */   TOWER_DEFAULTS: () => (/* binding */ TOWER_DEFAULTS),\n/* harmony export */   TOWER_GAT: () => (/* binding */ TOWER_GAT),\n/* harmony export */   TOWER_SPRAY: () => (/* binding */ TOWER_SPRAY)\n/* harmony export */ });\nconst TOWER_DEFAULTS = {\n    turretLength: 20,\n    roundsPerSecond: 4,\n    roundsPerShot: 1,\n    roundSpeed: 6,\n    roundDamage: 1,\n    roundRadius: 5,\n    roundSpray: 0.1,\n    roundType: 'pellet',\n    targettingRange: 150,\n    targettingType: 'auto',\n    roundCollats: 0,\n    fireDirection: 'forward',\n};\n\nconst TOWER_BASIC = {\n    id: 'basic',\n    name: 'Basic Tower',\n    cost: 100,\n    turretLength: 20,\n    roundsPerSecond: 4,\n    roundSpeed: 6,\n    roundDamage: 1,\n    roundRadius: 5,\n    roundSpray: 0.05,\n    roundType: 'pellet',\n    targettingRange: 150,\n    targettingType: 'auto',\n    roundCollats: 0,\n    upgrades: {\n        FasterFiring: {\n            id: 'faster-firing',\n            name: 'Faster Firing',\n            cost: 100,\n            effect: (tower) => {\n                tower.roundsPerSecond *= 1.5;\n            }\n        },\n        IncreasedRange: {\n            id: 'increased-range',\n            name: 'Increased Range',\n            cost: 100,\n            effect: (tower) => {\n                tower.targettingRange *= 1;\n            }\n        },\n        PiercingShot: {\n            id: 'piercing-shot',\n            name: 'Piercing Shot',\n            cost: 100,\n            effect: (tower) => {\n                tower.roundCollats += 2;\n            }\n        },\n        PiercingShot2: {\n            id: 'piercing-shot-2',\n            name: 'Piercing Shot 2',\n            cost: 200,\n            effect: (tower) => {\n                tower.roundCollats += 2;\n            }\n        }\n    }\n}\n\nconst TOWER_GAT = {\n    id: 'gat',\n    name: 'Gatling Gunner',\n    cost: 500,\n    turretLength: 65,\n    roundsPerSecond: 20,\n    roundSpeed: 12,\n    roundDamage: 1,\n    roundRadius: 5,\n    roundSpray: 0.11,\n    roundType: 'pellet',\n    targettingRange: 999,\n    targettingType: 'mouse',\n    roundCollats: 2,\n    upgrades: {}\n}\n\nconst TOWER_SPRAY = {\n    id: 'spray',\n    name: 'Spray Gunner',\n    cost: 300,\n    turretLength: 20,\n    roundsPerSecond: 3,\n    roundsPerShot: 12,\n    roundSpeed: 6,\n    roundDamage: 1,\n    roundRadius: 5,\n    roundSpray: 0,\n    roundType: 'pellet',\n    targettingRange: 75,\n    targettingType: 'auto',\n    roundCollats: 0,\n    fireDirection: 'around',\n    upgrades: {}\n}\n\n\n//# sourceURL=webpack://walker/./walker/objects/towers.js?");

/***/ }),

/***/ "./walker/objects/travellers.js":
/*!**************************************!*\
  !*** ./walker/objects/travellers.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AFFLICTIONS: () => (/* binding */ AFFLICTIONS),\n/* harmony export */   BLOON_BLACK: () => (/* binding */ BLOON_BLACK),\n/* harmony export */   BLOON_BLUE: () => (/* binding */ BLOON_BLUE),\n/* harmony export */   BLOON_DEFAULTS: () => (/* binding */ BLOON_DEFAULTS),\n/* harmony export */   BLOON_GREEN: () => (/* binding */ BLOON_GREEN),\n/* harmony export */   BLOON_PINK: () => (/* binding */ BLOON_PINK),\n/* harmony export */   BLOON_RED: () => (/* binding */ BLOON_RED),\n/* harmony export */   BLOON_WHITE: () => (/* binding */ BLOON_WHITE),\n/* harmony export */   BLOON_YELLOW: () => (/* binding */ BLOON_YELLOW),\n/* harmony export */   TRAITS: () => (/* binding */ TRAITS)\n/* harmony export */ });\n\nconst AFFLICTIONS = {\n    freeze: {\n        duration: 1000,\n        effect: (traveller) => {\n            traveller.pathVelocity = traveller.speed * 0.5;\n        },\n        remove: (traveller) => {\n            traveller.pathVelocity = traveller.speed;\n        }\n    },\n};\n\nconst TRAITS = {\n    camo: {\n        effect: (traveller) => {\n            traveller.camo = true;\n        }\n    },\n    fortified: {\n        effect: (traveller) => {\n            traveller.fortified = true;\n        }\n    },\n    regen: {\n        effect: (traveller) => {\n            traveller.regen = true;\n        }\n    },\n    shielded: {\n        effect: (traveller) => {\n            traveller.shielded = true;\n        }\n    },\n    metal: {\n        effect: (traveller) => {\n            traveller.metal = true;\n        }\n    },\n};\n\n/* BLOONS */\nconst BLOON_DEFAULTS = {\n    id: 'bloon',\n    health: 1,\n    speed: 2,\n    damage: 1,\n    radius: 12,\n    next: null\n};\n\nconst BLOON_RED = {\n    id: 'bloon-red',\n    health: 1,\n    speed: 1.0,\n    damage: 1,\n};\n\nconst BLOON_BLUE = {\n    id: 'bloon-blue',\n    health: 1,\n    speed: 1.2,\n    damage: 2,\n    radius: 13,\n    next: {\n        type: BLOON_RED,\n        count: 1,\n    }\n};\n\nconst BLOON_GREEN = {\n    id: 'bloon-green',\n    health: 1,\n    speed: 1.5,\n    damage: 4,\n    radius: 14,\n    next: {\n        type: BLOON_BLUE,\n        count: 1,\n    }\n};\n\nconst BLOON_YELLOW = {\n    id: 'bloon-yellow',\n    health: 1,\n    speed: 1.8,\n    damage: 5,\n    radius: 15,\n    next: {\n        type: BLOON_GREEN,\n        count: 1,\n    }\n};\n\nconst BLOON_PINK = {\n    id: 'bloon-pink',\n    health: 1,\n    speed: 2.0,\n    damage: 6,\n    radius: 15,\n    next: {\n        type: BLOON_YELLOW,\n        count: 1,\n    }\n};\n\nconst BLOON_BLACK = {\n    id: 'bloon-black',\n    health: 1,\n    speed: 2.0,\n    damage: 7,\n    radius: 9,\n    next: {\n        type: BLOON_PINK,\n        count: 2,\n    }\n};\n\nconst BLOON_WHITE = {\n    id: 'bloon-white',\n    health: 1,\n    speed: 2.0,\n    damage: 7,\n    radius: 9,\n    next: {\n        type: BLOON_PINK,\n        count: 2,\n    }\n};\n\n\n//# sourceURL=webpack://walker/./walker/objects/travellers.js?");

/***/ }),

/***/ "./walker/particle.js":
/*!****************************!*\
  !*** ./walker/particle.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Particle: () => (/* binding */ Particle)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./walker/constants.js\");\n\n\nclass Particle {\n    constructor(state, x, y, xv, yv, type, range, damage, collats) {\n        this.state = state;\n        this.range = range || 100;\n        this.travelDist = 0;\n        this.x = x;\n        this.y = y;\n        this.xv = xv;\n        this.yv = yv;\n        this.radius = 4;\n        this.type = type;\n        this.damage = damage || 0;\n\n        this.hitlist = [];\n        \n        this.life = 9999;\n        this.collats = collats || 0;\n\n        const mag = Math.sqrt(Math.pow(this.xv, 2) + Math.pow(this.yv, 2));\n        this.speed = mag;\n\n        if (this.type === 'pellet') {\n            this.radius = 4;\n        } else if (this.type === 'pop') {\n            this.radius = 22;\n            this.life = 6;\n        }\n    }\n\n    update() {\n        this.life -= 1;\n\n        if (this.type === 'pop') {\n            this.radius = 22 * (this.life / 6);\n            return;\n        }\n\n        this.x += this.xv;\n        this.y += this.yv;\n        this.travelDist += this.speed;\n\n        const hitIds = this.state.travellerColliding(this.x, this.y, this.radius, this.damage, this.hitlist);\n        if (hitIds !== false) {\n            hitIds.forEach(id => {\n                if (this.hitlist.indexOf(id) === -1) {\n                    this.hitlist.push(id);\n                }\n            });\n            if (this.collats <= 0) {\n                this.life = 0;\n            } else {\n                this.collats--;\n            }\n        }\n    }\n\n    draw(ctx) {\n        if (this.type === 'pellet') {\n            ctx.fillStyle = \"black\";\n        } else if (this.type === 'pop') {\n            ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\";\n        }\n\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.radius, 0, _constants_js__WEBPACK_IMPORTED_MODULE_0__.FULL_CIRCLE);\n        ctx.fill();\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/particle.js?");

/***/ }),

/***/ "./walker/path.js":
/*!************************!*\
  !*** ./walker/path.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathPartBezier: () => (/* binding */ PathPartBezier),\n/* harmony export */   PathPartLine: () => (/* binding */ PathPartLine)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./walker/util.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./walker/constants.js\");\n\n\n\nclass PathPart {\n    constructor() {\n        this.type = 'none';\n        this.length = 0;\n        this.hoveredPoint = -1;\n        this.mode = 'final';\n        this.layer = 0;\n    }\n\n    getOrigin() {\n        return;\n    }\n\n    getPoint(i) {\n        return;\n    }\n\n    getHoveredPoint() {\n        if (this.hoveredPoint === -1 || this.mode !== 'final') {\n            return null;\n        }\n        return this.getPoint(this.hoveredPoint);\n    }\n\n    f(t) {\n        return 0;\n    }\n\n    update(mouse) {\n        return;\n    }\n\n    draw(ctx) {\n        return;\n    }\n\n    isColliding(x, y, radius) {\n        return false;\n    }\n}\n\n\nclass PathPartLine extends PathPart {\n    constructor(x1, y1, x2, y2) {\n        super();\n        this.type = 'line';\n\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.length = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x1, y: y1}, {x: x2, y: y2});\n    }\n\n    getOrigin() {\n        return {\n            x: this.x1,\n            y: this.y1,\n        }\n    }\n\n    getPoint(i) {\n        if (i === 0) {\n            return { x: this.x1, y: this.y1 };\n        } else if (i === 1) {\n            return { x: this.x2, y: this.y2 };\n        }\n        return null;\n    }\n\n    f(t) {\n        return {\n            x: this.x1 + (this.x2 - this.x1) * t,\n            y: this.y1 + (this.y2 - this.y1) * t,\n        }\n    }\n\n    isColliding(x, y, radius) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.lineColliding)(x, y, this.x1, this.y1, this.x2, this.y2, radius);\n    }\n\n    pointColliding(x, y, radius) {\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x1, y: this.y1}) < radius) {\n            return 0;\n        } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x2, y: this.y2}) < radius) {\n            return 1;\n        }\n    }\n\n    update(mouse) {\n        super.update(mouse);\n\n        if (!_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE) {\n            return;\n        }\n\n        if (this.mode === 'follow') {\n            this.x2 = mouse.x;\n            this.y2 = mouse.y;\n            this.length = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: this.x1, y: this.y1}, {x: this.x2, y: this.y2});\n\n            if (mouse.down) {\n                this.mode = 'final';\n            }\n\n            return;\n        }\n\n        if (!mouse.down) {\n            this.hoveredPoint = -1;\n            this.hoveredPoint = this.pointColliding(mouse.x, mouse.y, 10);\n        }\n        \n        if (this.hoveredPoint !== -1) {\n            if (mouse.down) {\n                if (this.hoveredPoint === 0) {\n                    this.x1 = mouse.x;\n                    this.y1 = mouse.y;\n                } else if (this.hoveredPoint === 1) {\n                    this.x2 = mouse.x;\n                    this.y2 = mouse.y;\n                }\n                this.length = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: this.x1, y: this.y1}, {x: this.x2, y: this.y2});\n            }\n        }\n    }\n\n    draw(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.x1, this.y1);\n        ctx.lineTo(this.x2, this.y2);\n        ctx.stroke();\n\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE) {\n            const points = [[this.x1, this.y1], [this.x2, this.y2]];\n            points.forEach((point, index) => {\n                ctx.fillStyle = \"red\";\n                if (this.hoveredPoint === index) {\n                    ctx.fillStyle = \"white\";\n                }\n                ctx.beginPath();\n                ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);\n                ctx.fill();\n            });\n        }\n    }\n}\n\n\nclass PathPartBezier extends PathPart {\n    constructor(x1, y1, x2, y2, x3, y3, x4, y4) {\n        super();\n        this.type = 'bezier';\n\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n\n        this.x3 = x3;\n        this.y3 = y3;\n        this.x4 = x4;\n        this.y4 = y4;\n\n        this.lengthPrecision = 200;\n        this.collidePrecision = 20;\n        this.length = this.calcLength();\n    }\n\n    calcLength() {\n        let length = 0;\n        let lastPoint = this.f(0);\n        for (let i = 1; i <= this.lengthPrecision; i++) {\n            const point = this.f(i / this.lengthPrecision);\n            length += (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: lastPoint.x, y: lastPoint.y}, {x: point.x, y: point.y})\n            lastPoint = point;\n        }\n        return length;\n    }\n\n    getOrigin() {\n        return {\n            x: this.x1,\n            y: this.y1,\n        }\n    }\n\n    getPoint(i) {\n        if (i === 0) {\n            return { x: this.x1, y: this.y1 };\n        } else if (i === 1) {\n            return { x: this.x2, y: this.y2 };\n        } else if (i === 2) {\n            return { x: this.x3, y: this.y3 };\n        } else if (i === 3) {\n            return { x: this.x4, y: this.y4 };\n        }\n        return null;\n    }\n\n    f(t) {\n        return {\n            x: Math.pow(1 - t, 3) * this.x1 + 3 * t * Math.pow(1 - t, 2) * this.x2 + 3 * Math.pow(t, 2) * (1 - t) * this.x3 + Math.pow(t, 3) * this.x4,\n            y: Math.pow(1 - t, 3) * this.y1 + 3 * t * Math.pow(1 - t, 2) * this.y2 + 3 * Math.pow(t, 2) * (1 - t) * this.y3 + Math.pow(t, 3) * this.y4,\n        }\n    }\n\n    isColliding(x, y, radius) {\n        let lastPoint = this.f(0);\n        \n        for (let i = 1; i <= this.collidePrecision; i++) {\n            const point = this.f(i / this.collidePrecision);\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.lineColliding)(x, y, lastPoint.x, lastPoint.y, point.x, point.y, radius)) {\n                return true;\n            }\n            lastPoint = point;\n        }\n        return false;\n    }\n\n    pointColliding(x, y, radius) {\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x1, y: this.y1}) < radius) {\n            return 0;\n        } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x2, y: this.y2}) < radius) {\n            return 1;\n        } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x3, y: this.y3}) < radius) {\n            return 2;\n        } else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)({x: x, y: y}, {x: this.x4, y: this.y4}) < radius) {\n            return 3;\n        }\n        return -1;\n    }\n\n    update(mouse) {\n        super.update(mouse);\n\n        if (!_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE) {\n            return;\n        }\n\n        if (this.mode === 'follow') {\n            this.x4 = mouse.x;\n            this.y4 = mouse.y;\n            this.x2 = this.x1 + (this.x4 - this.x1) / 3;\n            this.y2 = this.y1 + (this.y4 - this.y1) / 3;\n            this.x3 = this.x1 + (this.x4 - this.x1) * 2 / 3;\n            this.y3 = this.y1 + (this.y4 - this.y1) * 2 / 3;\n            this.length = this.calcLength();\n\n            if (mouse.down) {\n                this.mode = 'final';\n            }\n\n            return;\n        }\n\n        if (!mouse.down) {\n            this.hoveredPoint = this.pointColliding(mouse.x, mouse.y, 10);\n        }\n        \n        if (this.hoveredPoint !== -1) {\n            if (mouse.down) {\n                if (this.hoveredPoint === 0) {\n                    this.x1 = mouse.x;\n                    this.y1 = mouse.y;\n                } else if (this.hoveredPoint === 1) {\n                    this.x2 = mouse.x;\n                    this.y2 = mouse.y;\n                } else if (this.hoveredPoint === 2) {\n                    this.x3 = mouse.x;\n                    this.y3 = mouse.y;\n                } else if (this.hoveredPoint === 3) {\n                    this.x4 = mouse.x;\n                    this.y4 = mouse.y;\n                }\n                this.length = this.calcLength();\n            }\n        }\n    }\n\n    draw(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.x1, this.y1);\n        ctx.bezierCurveTo(this.x2, this.y2, this.x3, this.y3, this.x4, this.y4);\n        ctx.stroke();\n\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG) {\n            ctx.strokeStyle = \"red\";\n            ctx.lineWidth = 0.5;\n            ctx.beginPath();\n            ctx.arc(this.x2, this.y2, 2, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.arc(this.x3, this.y3, 2, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE) {\n            const points = [[this.x1, this.y1], [this.x4, this.y4]];\n            points.forEach((point, index) => {\n                ctx.fillStyle = \"red\";\n                if (this.hoveredPoint === index) {\n                    ctx.fillStyle = \"white\";\n                }\n                ctx.beginPath();\n                ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);\n                ctx.fill();\n            });\n        }\n    }\n}\n\n\nclass Path {\n    constructor() {\n        this.parts = []; // array of PathPart\n        this.hoveredPart = -1;\n    }\n\n    partColliding(x, y, radius) {\n        for (let i = 0; i < this.parts.length; i++) {\n            const part = this.parts[i];\n            if (part.isColliding(x, y, radius)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    addPart(part) {\n        this.parts.push(part);\n    }\n\n    removePart(index) {\n        this.parts.splice(index, 1);\n    }\n\n    save() {\n        const data = {\n            path: []\n        };\n\n        this.parts.forEach(part => {\n            const partData = {\n                type: part.type,\n                layer: part.layer || 3,\n                points: [],\n            }\n            if (part.type === 'line') {\n                partData.points.push([part.x1, part.y1]);\n                partData.points.push([part.x2, part.y2]);\n            } else if (part.type === 'bezier') {\n                partData.points.push([part.x1, part.y1]);\n                partData.points.push([part.x2, part.y2]);\n                partData.points.push([part.x3, part.y3]);\n                partData.points.push([part.x4, part.y4]);\n            }\n            data.path.push(partData);\n        });\n\n        console.log(JSON.stringify(data, null, 4));\n    }\n\n    update(scene) {\n        if (!_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE || !_constants_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG) {\n            return;\n        }\n\n        this.hoveredPart = this.partColliding(scene.mouse.x, scene.mouse.y, 10);\n\n        this.parts.forEach(part => {\n            part.update(scene.mouse);\n        });\n\n        if (scene.keyPress('s')) {\n            this.save();\n        }\n\n        if (this.hoveredPart === -1) {\n            return;\n        }\n\n        const hoveredPart = this.parts[this.hoveredPart];\n        const hoveredPoint = hoveredPart.getHoveredPoint();\n        if (hoveredPoint !== null) {\n            let newPart = null;\n\n            if (scene.keyPress('1')) {\n                newPart = new PathPartLine(hoveredPoint.x, hoveredPoint.y, hoveredPoint.x, hoveredPoint.y);\n            } else if (scene.keyPress('2')) {\n                newPart = new PathPartBezier(hoveredPoint.x, hoveredPoint.y, hoveredPoint.x, hoveredPoint.y, hoveredPoint.x, hoveredPoint.y, hoveredPoint.x, hoveredPoint.y);\n            }\n\n            if (newPart !== null) {\n                newPart.mode = 'follow';\n                this.addPart(newPart);\n            }\n        }\n    }\n\n    draw(ctx) {\n        ctx.lineWidth = 2;\n        this.parts.forEach((part, index) => {\n            ctx.lineWidth = 1;\n            if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.EDIT_MODE && _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG && index === this.hoveredPart) {\n                ctx.strokeStyle = \"blue\";\n                ctx.fillStyle = 'black';\n                ctx.font = '16px Arial';\n                const {x, y} = part.getOrigin();\n                ctx.fillText(`[${index}, ${part.layer}]`, x, y - 10);\n            } else {\n                ctx.strokeStyle = \"black\";\n            }\n            part.draw(ctx);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/path.js?");

/***/ }),

/***/ "./walker/resource.js":
/*!****************************!*\
  !*** ./walker/resource.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LevelResource: () => (/* binding */ LevelResource),\n/* harmony export */   SpriteResource: () => (/* binding */ SpriteResource)\n/* harmony export */ });\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ \"./walker/path.js\");\n\n\nconst RES_DIR = 'res';\nconst RES_LEVEL = 'level';\n\nconst LEVEL_LAYER_MAX = 6;\n\nclass Resource {\n    constructor(type, id) {\n        this.type = type;\n        this.loaded = false;\n        this.path = `${RES_DIR}/${type}/${id}`;\n        this.id = id;\n    }\n\n    async load() {\n        this.loaded = true;\n    }\n\n    draw(ctx, layer) {\n        return;\n    }\n}\n\n\nclass SpriteResource extends Resource {\n    constructor(id) {\n        super(RES_SPRITE, id);\n    }\n}\n\n\nclass LevelResource extends Resource {\n    constructor(id) {\n        super(RES_LEVEL, id);\n\n        this.layers = Array.from({length: LEVEL_LAYER_MAX}, () => null);\n        this.paths = [];\n    }\n\n    async load() {\n        const levelData = await fetch(`${this.path}/${this.id}.json`)\n            .then((response) => response.json());\n\n        const layerFiles = levelData.layers;\n        const expectLayerCount = layerFiles.filter(layer => layer !== null).length;\n        layerFiles.forEach(async (layer, index) => {\n            if (layer === null) {\n                return;\n            }\n            const layerElement = document.createElement('img');\n            layerElement.src = `${this.path}/${layer}`;\n            layerElement.onload = () => {\n                this.layers[index] = layerElement;\n            }\n        });\n\n        let waitCount = 0;\n        while (this.layers.filter(layer => layer === null).length < expectLayerCount) {\n            // console.log(`waiting for level '${this.id}' to load...`);\n            await new Promise(resolve => setTimeout(resolve, 100));\n            if (waitCount++ > 10) {\n                const errorMsg = `[Resource ${this.type}] FAILED to load level '${this.id}'`;\n                // console.log(errorMsg);\n                throw new Error(errorMsg);\n            }\n        }\n\n        levelData.paths.forEach((pathData, pathIndex) => {\n            const path = new _path_js__WEBPACK_IMPORTED_MODULE_0__.Path();\n            pathData.path.forEach((pathPartData, pathPartIndex) => {\n                const points = pathPartData.points;\n                const pathErorMsg = `[Resource ${this.type}] invalid path part data for path ${pathIndex} part ${pathPartIndex}`;\n                let newPart;\n                if (pathPartData.type === 'line') {\n                    if (points.length !== 2) {\n                        throw new Error(pathErorMsg);\n                    }\n                    newPart = new _path_js__WEBPACK_IMPORTED_MODULE_0__.PathPartLine(points[0][0], points[0][1], points[1][0], points[1][1]);\n                } else if (pathPartData.type === 'bezier') {\n                    if (points.length !== 4) {\n                        throw new Error(pathErorMsg);\n                    }\n                    newPart = new _path_js__WEBPACK_IMPORTED_MODULE_0__.PathPartBezier(points[0][0], points[0][1], points[1][0], points[1][1], points[2][0], points[2][1], points[3][0], points[3][1]);\n                }\n                newPart.layer = pathPartData.layer;\n                path.addPart(newPart);\n            });\n            this.paths.push(path);\n        });\n\n        console.log(`[Resource ${this.type}] loaded '${this.id}' with ${expectLayerCount}/${LEVEL_LAYER_MAX} layers`);\n\n        this.loaded = true;\n    }\n\n    draw(ctx, layer) {\n        if (this.layers.length <= layer || this.layers[layer] === null) {\n            return;\n        }\n        \n        const drawLayer = this.layers[layer];\n\n        ctx.drawImage(drawLayer, 0, 0);\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/resource.js?");

/***/ }),

/***/ "./walker/scene.js":
/*!*************************!*\
  !*** ./walker/scene.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _level_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./level.js */ \"./walker/level.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state.js */ \"./walker/state.js\");\n\n\n\nclass Scene {\n    constructor() {\n        this.frameNum = 0;\n        this.mouse = {\n            x: 0,\n            y: 0,\n            down: false\n        };\n        this.keys = {};\n        this.running = false;\n        this.debugInfo = {};\n        this.debugInfoElement = document.getElementById('debug-info');\n        this.setupCanvas();\n\n        // implementation\n        this.state = new _state_js__WEBPACK_IMPORTED_MODULE_1__.State(this);\n\n        return this;\n    }\n\n    async load() {\n        this.level = new _level_js__WEBPACK_IMPORTED_MODULE_0__.Level(this.state);\n        await this.level.loadLevel('grass');\n\n        this.level.injectTestLevel();\n        this.level.createTestSpawn();\n\n        return this;\n    }\n\n    start() {\n        this.running = true;\n        requestAnimationFrame(() => this.loop());\n    }\n\n    loop() {\n        this.ctx.clearRect(0, 0, canvas.width, canvas.height);\n        this.ctx.fillStyle = 'rgb(220, 255, 220)';\n        this.ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n        this.state.update();\n        this.state.draw(this.ctx);\n    \n        this.frameNum++;\n    \n        this.renderDebug();\n\n        if (this.running) {\n            requestAnimationFrame(() => this.loop());\n        }\n    }\n\n    keyPress(key) {\n        if (this.keys[key] && this.keys[key].press === this.frameNum) {\n            return true;\n        }\n        return false;\n    }\n\n    setDebugField(field, value) {\n        this.debugInfo[field] = value;\n    }\n    \n    renderDebug() {\n        if (!this.debugInfoElement) {\n            return;\n        }\n        this.debugInfoElement.innerHTML = '';\n        for (const [key, value] of Object.entries(this.debugInfo)) {\n            const p = document.createElement('span');\n            p.innerHTML = `${key}: ${value}`;\n            this.debugInfoElement.appendChild(p);\n        }\n    }\n\n    setupCanvas() {\n        const canvas = document.getElementById('canvas');\n        canvas.width = canvas.offsetWidth;\n        canvas.height = canvas.offsetHeight;\n        const ctx = canvas.getContext('2d');\n\n        window.addEventListener('resize', () => {\n            canvas.width = canvas.offsetWidth;\n            canvas.height = canvas.offsetHeight;\n        }, false);\n\n        window.addEventListener('keydown', e => {\n            const key = e.key;\n            if (key === ' ') {\n                e.preventDefault();\n            }\n            if (!this.keys[key]) {\n                this.keys[key] = {};\n            }\n            if (!this.keys[key].down) {\n                this.keys[key].down = true;\n                this.keys[key].press = this.frameNum;\n                // console.log(`[Key] ${key} down`);\n            } else {\n                this.keys[key].press = false;\n            }\n            this.keys[key].release = false;\n        });\n\n        window.addEventListener('keyup', e => {\n            const key = e.key;\n            if (!this.keys[key]) {\n                this.keys[key] = {};\n            }\n            if (this.keys[key].down) {\n                this.keys[key].down = false;\n                this.keys[key].release = this.frameNum;\n            } else {\n                this.keys[key].release = false;\n            }\n            this.keys[key].press = false;\n        });\n        \n        canvas.addEventListener('mousemove', e => {\n            const rect = canvas.getBoundingClientRect();\n            this.mouse.x = e.clientX - rect.left;\n            this.mouse.y = e.clientY - rect.top;\n        });\n        \n        canvas.addEventListener('mousedown', e => {\n            this.mouse.down = true;\n        });\n        \n        canvas.addEventListener('mouseup', e => {\n            this.mouse.down = false;\n        });\n        \n        canvas.addEventListener('mouseleave', e => {\n            this.mouse.down = false;\n        });\n\n        // why not working\n        window.dispatchEvent(new Event('resize'));\n\n        this.canvas = canvas;\n        this.ctx = ctx;\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/scene.js?");

/***/ }),

/***/ "./walker/state.js":
/*!*************************!*\
  !*** ./walker/state.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   State: () => (/* binding */ State)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./walker/constants.js\");\n/* harmony import */ var _particle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./particle.js */ \"./walker/particle.js\");\n/* harmony import */ var _traveller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./traveller.js */ \"./walker/traveller.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"./walker/util.js\");\n\n\n\n\n\n/* DATA */\nclass State {\n    constructor(scene) {\n        this.scene = scene;\n        this.paths = []; // array of Path\n        this.hoveredPath = -1;\n        this.hoveredPart = -1;\n        \n        this.travellers = []; // array of Traveller\n        this.travellersByDistance = []; // array of Traveller\n        this.travellersByStrength = []; // array of Traveller\n\n        this.layerResources = [];\n\n        this.towers = []; // array of Tower\n        this.particles = []; // array of Particle\n\n        this.time = 0;\n        this.lastTime = 0;\n\n        this.lives = 100;\n\n        this.globalTravellerId = 0;\n    }\n\n    update() {\n        this.paths.forEach(path => {\n            path.update(this.scene);\n        });\n\n        const travellerDestroy = [];\n        this.travellers.forEach(traveller => {\n            traveller.update();\n    \n            if (traveller.lifespent > traveller.lifetime) {\n                travellerDestroy.push(traveller);\n            }\n\n            if (traveller.health <= 0) {\n                travellerDestroy.push(traveller);\n            }\n    \n            if (traveller.baseType === 'bloon' && !traveller.usingPath()) {\n                travellerDestroy.push(traveller);\n                this.lives -= traveller.damage;\n                // console.log(`lost a life, ${this.lives} remaining`);\n            }\n        });\n    \n        travellerDestroy.forEach(traveller => {\n            this.removeTraveller(traveller);\n        });\n\n        this.travellersByDistance = this.travellers.slice();\n        this.travellersByDistance.sort((a, b) => {\n            return b.pathTotalDistance - a.pathTotalDistance;\n        });\n\n        this.travellersByStrength = this.travellersByDistance.slice();\n        this.travellersByStrength.sort((a, b) => {\n            const healthDiff = b.maxHealth - a.maxHealth;\n            if (healthDiff !== 0) {\n                return healthDiff;\n            }\n            return b.pathTotalDistance - a.pathTotalDistance;\n        });\n    \n        this.towers.forEach(tower => {\n            tower.update();\n        });\n\n        const particleDestroy = [];\n        this.particles.forEach(particle => {\n            particle.update();\n\n            if (\n                particle.life <= 0\n                || particle.travelDist > particle.range) \n            {\n                particleDestroy.push(particle);\n            }\n        });\n\n        particleDestroy.forEach(particle => {\n            this.removeParticle(particle);\n        });\n\n        this.scene.setDebugField('travellers', this.travellers.length);\n        this.scene.setDebugField('particles', this.particles.length);\n    }\n\n    draw(ctx) {\n        const layers = Array.from({length: _constants_js__WEBPACK_IMPORTED_MODULE_0__.LEVEL_LAYER_MAX}, () => {\n            return {\n                travellers: [],\n            };\n        });\n\n        this.travellers.forEach(traveller => {\n            layers[traveller.getPathLayer()].travellers.push(traveller);\n        });\n\n        // LAYERED layers\n        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.LEVEL_LAYER_MAX; i++) {\n            this.layerResources.forEach(resource => {\n                resource.draw(ctx, i);\n            });\n\n            // TOWER (mid) layer\n            if (i === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LEVEL_LAYER_MIDDLE) {\n                this.towers.forEach(tower => {\n                    tower.draw(ctx);\n                });\n            }\n\n            layers[i].travellers.forEach(traveller => {\n                traveller.draw(ctx);\n            });\n        }\n\n        // TOP layer\n        this.particles.forEach(particle => {\n            particle.draw(ctx);\n        });\n\n        // DEBUG and EDIT layers\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG || _constants_js__WEBPACK_IMPORTED_MODULE_0__.EDIT_MODE) {\n            this.paths.forEach(path => {\n                path.draw(ctx);\n            });\n        }\n    }\n\n\n    /* ENTITY MANGEMENT */\n    addLayerResource(resource) {\n        this.layerResources.push(resource);\n    }\n\n    addPath(path) {\n        this.paths.push(path);\n    }\n\n    addTraveller(traveller) {\n        traveller.id = this.globalTravellerId++;\n        this.travellers.push(traveller);\n        return traveller.id;\n    }\n\n    removeTraveller(traveller) {\n        this.removeTravellerIndex(this.travellers.indexOf(traveller));\n    }\n\n    removeTravellerIndex(index) {\n        this.towers.forEach(tower => {\n            tower.removeTarget(this.travellers[index]);\n        });\n        this.travellers.splice(index, 1);\n    }\n\n    addTower(tower) {\n        this.towers.push(tower);\n    }\n\n    addParticle(particle) {\n        this.particles.push(particle);\n    }\n\n    removeParticle(particle) {\n        this.particles.splice(this.particles.indexOf(particle), 1);\n    }\n\n    removeParticleIndex(index) {\n        this.particles.splice(index, 1);\n    }\n\n\n    /* SYSTEMS */\n    acquireTarget(tower, currentTarget, stickyTarget) {\n        stickyTarget = stickyTarget === true;\n        const mode = tower.targettingMode || 'first';\n\n        let travellerList = this.travellers;\n\n        if (mode === 'first' || mode === 'last') {\n            travellerList = this.travellersByDistance;\n        } else if (mode === 'strongest') {\n            travellerList = this.travellersByStrength;\n        }\n\n        let target;\n        let stillInRange = false;\n        if (stickyTarget && currentTarget) {\n            target = currentTarget.ref;\n            stillInRange = (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.dist)({ x: target.x, y: target.y }, { x: tower.x, y: tower.y }) < tower.targettingRange;\n        }\n        if (!stillInRange) {\n            for (let i = 0; i < travellerList.length; i++) {\n                let j = i;\n                if (mode === 'last') {\n                    j = travellerList.length - 1 - i;\n                }\n                const traveller = travellerList[j];\n                // if (i > 0 && traveller.pathTotalDistance - travellerList[i - 1].pathTotalDistance >= 0) {\n                //     console.log(`WARNING: travellers not sorted: ${traveller.pathTotalDistance} >= ${travellerList[i - 1].pathTotalDistance}`);\n                // }\n                if ((0,_util_js__WEBPACK_IMPORTED_MODULE_3__.dist)({ x: traveller.x, y: traveller.y }, { x: tower.x, y: tower.y }) < tower.targettingRange) {\n                    target = traveller;\n                    break;\n                }\n            }\n        }\n\n        if (!target) {\n            tower.target = null;\n            return;\n        }\n\n        tower.target = {\n            ref: target,\n        };\n    }\n\n    travellerColliding(x, y, radius, damage, hitlist) {\n        for (let i = 0; i < this.travellers.length; i++) {\n            const traveller = this.travellers[i];\n        \n            if (hitlist.indexOf(traveller.id) !== -1) {\n                continue;\n            }\n\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_3__.dist)({x: traveller.x, y: traveller.y}, {x: x, y: y}) < (radius + (traveller.radius || 0))) {\n                const newHitlist = [];\n\n                if (damage) {\n                    traveller.health -= damage;\n                    if (traveller.health <= 0 && traveller.baseType === 'bloon') {\n                        if (traveller.next) {\n                            //console.log(`popped a ${traveller.type}, spawning ${traveller.next.count} ${traveller.next.type}`);\n                            for (let i = 0; i < traveller.next.count; i++) {\n                                const newTraveller = new _traveller_js__WEBPACK_IMPORTED_MODULE_2__.Traveller(traveller.x, traveller.y, traveller.path, traveller.next.type);\n                                newTraveller.pathIndex = traveller.pathIndex;\n                                newTraveller.pathT = traveller.pathT;\n                                newTraveller.pathTotalT = traveller.pathTotalT;\n                                newTraveller.pathTotalDistance = traveller.pathTotalDistance;\n                                newHitlist.push(this.addTraveller(newTraveller));\n\n                                this.particles.push(new _particle_js__WEBPACK_IMPORTED_MODULE_1__.Particle(this, traveller.x, traveller.y, 0, 0, 'pop'));\n                            }\n                        }\n\n                        this.removeTraveller(traveller);\n                    }\n                }\n        \n                return [traveller.id, ...newHitlist];\n            }\n        }\n\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/state.js?");

/***/ }),

/***/ "./walker/tower.js":
/*!*************************!*\
  !*** ./walker/tower.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: () => (/* binding */ Tower)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./walker/constants.js\");\n/* harmony import */ var _particle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./particle.js */ \"./walker/particle.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./walker/util.js\");\n/* harmony import */ var _objects_towers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./objects/towers.js */ \"./walker/objects/towers.js\");\n\n\n\n\n\nconst angles = [];\nconst angleStep = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FULL_CIRCLE / 8;\nfor (let i = 0; i < 8; i++) {\n    angles.push(i * angleStep);\n}\n\nclass Tower {\n    constructor(state, x, y, type) {\n        this.state = state;\n        this.x = x;\n        this.y = y;\n        this.type = type.id;\n\n        this.turretAngle = 0;\n\n        // {ref, distance, angle}\n        this.target = null;\n        this.targettingMode = 'first';\n        this.targettingRange = 80;\n        this.targettingType = 'auto';\n        this.fireDirection = 'forward';\n\n        this.lastRoundFiredTime = null;\n\n        this.upgrades = [];\n\n        Object.assign(this, _objects_towers_js__WEBPACK_IMPORTED_MODULE_3__.TOWER_DEFAULTS);\n        const traits = {...type};\n        delete traits.upgrades;\n        Object.assign(this, traits);\n    }\n\n    addUpgrade(upgrade) {\n        upgrade.effect(this);\n        this.upgrades.push(upgrade.id);\n    }\n\n    hasUpgrade(upgrade) {\n        return this.upgrades.find(up => up === upgrade);\n    }\n\n    fireRound() {\n        if (!this.target) {\n            return;\n        }\n        \n        const target = this.target.ref ? this.target.ref : this.target;\n        const roundsToAdd = [];\n\n        const angleStep = _constants_js__WEBPACK_IMPORTED_MODULE_0__.FULL_CIRCLE / this.roundsPerShot;\n        for (let i = 0; i < this.roundsPerShot; i++) {\n            let angle;\n            if (this.fireDirection === 'forward') {\n                angle = this.turretAngle + (Math.random() - 0.5) * this.roundSpray;\n            } else if (this.fireDirection === 'around') {\n                angle = (i * angleStep) + (Math.random() - 0.5) * this.roundSpray;\n            }\n\n            const x = this.x + Math.cos(angle) * this.turretLength;\n            const y = this.y + Math.sin(angle) * this.turretLength;\n            const xv = Math.cos(angle) * this.roundSpeed;\n            const yv = Math.sin(angle) * this.roundSpeed;\n        \n            roundsToAdd.push(new _particle_js__WEBPACK_IMPORTED_MODULE_1__.Particle(this.state, x, y, xv, yv, this.roundType, this.targettingRange, this.roundDamage, this.roundCollats));\n        }\n\n        roundsToAdd.forEach(r => {\n            this.state.addParticle(r);\n        });\n    }\n\n    update() {\n        const now = Date.now();\n        const diff = now - this.lastRoundFiredTime;\n        let shouldFire = false;\n        if (\n            this.lastRoundFiredTime === null \n            || diff > 1000 / this.roundsPerSecond\n        ) {\n            this.lastRoundFiredTime = now;\n            shouldFire = true;\n        }\n\n        let newTarget = this.state.scene.mouse;\n\n        if (this.state.travellers.length > 0 && this.targettingType === 'auto') {\n            // sort of a 'system' between these to entity types via state\n            this.state.acquireTarget(this, this.target || null, false);\n            if (!this.target) {\n                return;\n            }\n\n            newTarget = this.target.ref;\n        }\n\n        const distance = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.dist)({x: this.x, y: this.y}, {x: newTarget.x, y: newTarget.y});\n        const angle = Math.atan2((newTarget.y + 6) - this.y, (newTarget.x + 6) - this.x);\n        \n        this.target = {\n            ref: this.target ? this.target.ref : newTarget,\n            distance: distance,\n            angle: angle,\n        };\n\n        this.turretAngle = angle;\n\n        if (shouldFire) {\n            this.lastRoundFiredTime = now;\n            this.fireRound();\n        }\n    }\n\n    draw(ctx) {\n        let baseColor = [0, 0, 0];\n        let baseTurretColor = [150, 150, 150];\n        let baseTurretWidth = 4;\n\n        if (this.hasUpgrade('faster-firing')) {\n            // baseColor[1] += 200;\n            baseTurretColor[0] += 150;\n        }\n\n        if (this.hasUpgrade('piercing-shot')) {\n            baseTurretWidth += 4;\n        }\n\n        ctx.fillStyle = `rgb(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]})`;\n\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, 15, 0, 2 * Math.PI);\n        ctx.fill();\n\n        if (this.fireDirection === 'forward') {\n            ctx.strokeStyle = `rgb(${baseTurretColor[0]}, ${baseTurretColor[1]}, ${baseTurretColor[2]})`;\n            ctx.lineWidth = baseTurretWidth;\n            \n            ctx.beginPath();\n            ctx.moveTo(this.x, this.y);\n            ctx.lineTo(this.x + Math.cos(this.turretAngle) * this.turretLength, this.y + Math.sin(this.turretAngle) * this.turretLength);\n            ctx.stroke();\n        } else if (this.fireDirection === 'around') {\n            for (let i = 0; i < 8; i++) {\n                const angle = angles[i];\n                ctx.strokeStyle = `rgb(${baseTurretColor[0]}, ${baseTurretColor[1]}, ${baseTurretColor[2]})`;\n                ctx.lineWidth = baseTurretWidth;\n\n                ctx.beginPath();\n                ctx.moveTo(this.x, this.y);\n                ctx.lineTo(this.x + Math.cos(angle) * this.turretLength, this.y + Math.sin(angle) * this.turretLength);\n                ctx.stroke();\n            }\n        }\n\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG) {\n            ctx.strokeStyle = \"green\";\n            ctx.lineWidth = .5;\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.targettingRange, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }\n\n    removeTarget(traveller) {\n        if (this.target && this.target.ref === traveller) {\n            this.target = null;\n        }\n    }   \n}\n\n\n//# sourceURL=webpack://walker/./walker/tower.js?");

/***/ }),

/***/ "./walker/traveller.js":
/*!*****************************!*\
  !*** ./walker/traveller.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Traveller: () => (/* binding */ Traveller)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./walker/util.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./walker/constants.js\");\n/* harmony import */ var _objects_travellers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./objects/travellers.js */ \"./walker/objects/travellers.js\");\n\n\n\n\nclass Traveller {\n    constructor(x, y, path, type) {\n        this.path = path;\n        this.pathIndex = 0;\n        this.pathT = 0;\n        this.pathTotalT = 0;\n        this.pathTotalDistance = 0;\n\n        this.x = x;\n        this.y = y;\n        this.xv = 0;\n        this.yv = 0;\n        this.xa = 0;\n        this.ya = 0;\n        \n        this.type = type.id;\n        \n        this.health = 1;\n\n        this.pathVelocity = 0;\n        this.pathAcceleration = 0;\n\n        this.trailOn = false;\n        this.trail = [];\n\n        this.lifetime = 9999;\n        this.lifespent = 0;\n\n        this.setTravellerStats(type);\n    }\n\n    setTravellerStats(type) {\n        const typeSplit = type.id.split('-');\n        this.baseType = typeSplit[0];\n\n        this.maxHealth = this.health;\n        this.pathAcceleration = 0;\n\n        if (this.baseType !== 'bloon' || typeSplit.length < 2) {\n            return;\n        };\n\n        this.typeVariant = typeSplit[1];\n        Object.assign(this, _objects_travellers_js__WEBPACK_IMPORTED_MODULE_2__.BLOON_DEFAULTS);\n        // console.log(`assigning bloon stats to ${this.typeVariant}: ${JSON.stringify(type)}}`);\n        Object.assign(this, type);\n\n        this.pathVelocity = this.speed;\n    }\n\n    usingPath() {\n        return this.path !== null && this.path !== undefined;\n    }\n\n    getPathLayer() {\n        if (!this.usingPath()) {\n            return null;\n        }\n\n        return this.path.parts[this.pathIndex].layer;\n    }\n\n    departFromPath(part, remainingDistance) {\n        this.path = null;\n        this.pathIndex = 0;\n        this.pathT = 0;\n        this.xa = 0;\n        this.ya = 0;\n    }\n\n    traversePath() {\n        let part = this.path.parts[this.pathIndex];\n        \n        // desired distance to travel\n        const travelDist = this.pathVelocity;\n\n        // guess T to travel (acurrate for linear paths)\n        let moveT = travelDist / part.length;\n        \n        if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.PATH_TRAVERSE_ACCURATE) {\n            const acceptableError = moveT / 20.0;\n\n            // actual dist travelled\n            let actualDist = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)(part.f(this.pathT + moveT), part.f(this.pathT));\n\n            let deltaT =  0.5 * moveT;\n            const maxIterations = 20;\n            let iteration = 0;\n            \n            while (\n                (actualDist < travelDist - acceptableError \n                || actualDist > travelDist + acceptableError)\n                && iteration < maxIterations\n            ) {\n                deltaT = travelDist / actualDist * deltaT;\n                // console.log(actualDist - travelDist);\n                if (actualDist < travelDist) {\n                    moveT += deltaT;\n                } else {\n                    moveT -= deltaT;\n                }\n                deltaT /= 1.2;\n                actualDist = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.dist)(part.f(this.pathT + moveT), part.f(this.pathT));\n                iteration++;\n            }\n\n            this.pathTotalDistance += actualDist;\n        } else {\n            this.pathTotalDistance += travelDist;\n        }\n\n        this.pathT += moveT;\n        this.pathTotalT += moveT;\n\n        if (this.pathT >= 1) {\n            const remainingDistance = (this.pathT - 1) * part.length;\n        \n            this.pathIndex++;\n            if (this.pathIndex >= this.path.parts.length) {\n                this.departFromPath(part, remainingDistance);\n                return;\n            }\n        \n            part = this.path.parts[this.pathIndex];\n            this.pathT = remainingDistance / part.length;\n        }\n\n        if (this.pathT < 0) {\n            throw new Error('pathT < 0');\n        }\n\n        const pos = part.f(this.pathT);\n        this.xa = pos.x - this.x - this.xv;\n        this.ya = pos.y - this.y - this.yv;\n        this.xv = pos.x - this.x;\n        this.yv = pos.y - this.y;\n        this.x = pos.x;\n        this.y = pos.y;\n    }\n\n    update() {\n        if (this.trailOn) {\n            this.trail.push({x: this.x, y: this.y});\n            if (this.trail.length > 12) {\n                this.trail.shift();\n            }\n        }\n\n        if (this.usingPath()) {\n            this.pathVelocity += this.pathAcceleration;\n            this.traversePath();\n        } else {\n            this.xv *= AIR_DAMP;\n            this.yv *= AIR_DAMP;\n    \n            this.xv += this.xa;\n            this.yv += this.ya;\n            this.x += this.xv;\n            this.y += this.yv;\n        }\n\n        this.lifespent++;\n    }\n\n    draw(ctx) {\n        if (this.trailOn) {\n            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';\n            this.trail.forEach(point => {\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, 2, 0, 2 * Math.PI);\n                ctx.fill();\n            });\n        }\n\n        if (this.baseType === 'bloon') {\n            if (this.typeVariant === 'red') {\n                ctx.fillStyle = 'rgba(255, 0, 0, 1)';\n            } else if (this.typeVariant === 'blue') {\n                ctx.fillStyle = 'rgba(0, 0, 255, 1)';\n            } else if (this.typeVariant === 'green') {\n                ctx.fillStyle = 'rgba(0, 255, 0, 1)';\n            } else if (this.typeVariant === 'yellow') {\n                ctx.fillStyle = 'rgba(255, 255, 0, 1)';\n            } else if (this.typeVariant === 'pink') {\n                ctx.fillStyle = 'rgba(255, 0, 255, 1)';\n            } else if (this.typeVariant === 'black') {\n                ctx.fillStyle = 'rgba(0, 0, 0, 1)';\n            } else if (this.typeVariant === 'white') {\n                ctx.fillStyle = 'rgba(255, 255, 255, 1)';\n            } else if (this.typeVariant === 'lead') {\n                ctx.fillStyle = 'rgba(128, 128, 128, 1)';\n            } else if (this.typeVariant === 'zebra') {\n                ctx.fillStyle = 'rgba(255, 255, 255, 1)';\n            } else if (this.typeVariant === 'rainbow') {\n                ctx.fillStyle = 'rgba(255, 255, 255, 1)';\n            } else if (this.typeVariant === 'ceramic') {\n                ctx.fillStyle = 'rgba(255, 255, 255, 1)';\n            }\n\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n\n        if (_constants_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG) {\n            ctx.fillStyle = \"black\";\n            // draw text\n            ctx.font = \"12px Arial\";\n            // ctx.fillText(`${this.pathTotalDistance.toFixed(1)}`, this.x, this.y);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://walker/./walker/traveller.js?");

/***/ }),

/***/ "./walker/util.js":
/*!************************!*\
  !*** ./walker/util.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dist: () => (/* binding */ dist),\n/* harmony export */   lineColliding: () => (/* binding */ lineColliding)\n/* harmony export */ });\nfunction lineColliding(x, y, x1, y1, x2, y2, radius) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t < 0 || t > 1) {\n        return false;\n    }\n    const px = x1 + t * dx;\n    const py = y1 + t * dy;\n    return Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2)) < radius;\n}\n\nfunction dist({x: x1, y: y1}, {x: x2, y: y2}) {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\n\n//# sourceURL=webpack://walker/./walker/util.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;